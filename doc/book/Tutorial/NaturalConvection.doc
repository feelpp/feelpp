/* -*- mode: c++; coding: utf-8 -*- */
namespace Feel {
    /** \page NaturalConvection Natural Convection in a heated Tank
\author Christophe Prud'homme

\tableofcontents
<br>
<hr>
<br>

\section Description Description
The goal of this project is to simulate the fluid flow under natural convection: the heated fluid circulates towards the low temperature under the action of density and gravity differences. Thie phenomenon is important in the sense it models evacuation of heat, generated by friction forces for example, with  a cooling fluid.

We shall put in place a simple convection problem in order to study the phenomenon without having to handle the difficulties of more complex domaines. We describe then some necessary transformations to the equations, then we define quantities of interest to be able to compare the simulations with different parameter values.


To study the convection, we use a model problem: it consists in a rectangular tank of height \f$1\f$ and width \f$W\f$, in which the fluid is enclosed : 
<center>
<table border=0px>
<tr>
  <td>\image html convection_geo.png</td>
</tr>
<tr>
  <td><center>Geometry of the model</center></td>
</tr>
</table>
</center>
We wish to know the fluid velocity \f$\mathbf{u}\f$, the fluid pressure \f$p\f$ and fluid temperature \f$\theta\f$.

We introduce the adimensionalized Navier-Stokes and heat equations parametrized by the Grashof and Prandtl numbers. These parameters allow to describe the various regimes of the fluid flow and heat transfer in the tank when varying them.

The adimensionalized steady incompressible Navier-Stokes equations reads:
\f{equation*}
  \begin{split}
    \mathbf{u}\cdot\nabla \mathbf{u} +\nabla p -\frac{1}{\sqrt{\Gr}} \Delta \mathbf{u} &= \theta \mathbf{e}_2\\
    \nabla \cdot \mathbf{u} & = 0\ \text{sur}\ \Omega\\
    \mathbf{u} & = \mathbf{0}\ \text{sur}\ \partial \Omega
  \end{split}
\f}
where \f$\Gr\f$ is the Grashof number, \f$\mathbf{u}\f$ the adimensionalized velocity and \f$p\f$ adimensionalized pressure and \f$\theta\f$ the adimensionalized temperature. The temperature is in fact the difference between the temperature in the tank and the temperature \f$T_0\f$ on boundary \f$\Gamma_1\f$.

The heat equation reads:
\f{equation*}
  \begin{split}
    \mathbf{u} \cdot \nabla \theta -\frac{1}{\sqrt{\Gr}\Pr} \Delta \theta &= 0\\
    \theta &= 0\ \text{sur}\ \Gamma_1\\
    \frac{\partial \theta}{\partial n} &= 0\ \text{sur}\ \Gamma_{2,4}\\
    \frac{\partial \theta}{\partial n} &= 1\ \text{sur}\ \Gamma_3
  \end{split}
\f}
where \f$\Pr\f$ is the Prandtl number.


\section Influence Influence of parameters
What are the effects of the Grashof and Prandtl numbers ? We remark
that both terms with these parameters appear in front of the \f$\Delta\f$
parameter, they thus act on the diffusive terms. If we increase the
Grashof number or the Prandtl number the coefficients multiplying the
diffusive terms decrease, and this the convection, that is to say the
transport of the heat via the fluid, becomes dominant. This leads also
to a more difficult and complex flows to simulate. The influence of the Grashof and Prandtl
numbers are different but they generate similar difficulties and flow
configurations. Thus we look only here at the influence of the Grashof
number which shall vary in \f$[1, 1e7]\f$.
<center>
<table border=0px>
<tr>
  <td>\image html flow_grashof.png</td>
</tr>
<tr>
  <td><center>Velocity norm with respect to  Grashof, \f$ Gr=100, 10000,
    100000, 500000\f$.<br> \f$h=0.01\f$ and \f$\Pr=1\f$.</center></td>
</tr>
</table>
</center>


\section Quantities Quantities of interest
We would like to compare the results of many simulations with respect
to the Grashof defined in the previous section. We introduce two
quantities which will allow us to observe the behavior of the flow and
heat transfer.

\subsection Quantities_Mean Mean temperature
We consider first the mean temperature on boundary \f$\Gamma_3\f$
\f{equation*}
  T_3 = \int_{\Gamma_3} \theta
\f}

This quantity should decrease with increasing Grashof because the
fluid flows faster and will transport more heat which will cool down
the heated boundary \f$\Gamma_3\f$. We observe this behavior on this
figure.
<center>
<table border=0px>
<tr>
  <td>\image html temp_grashof.png</td>
</tr>
<tr>
  <td><center>Mean temperature with respect to the Grashof number;<br>
    \f$h=0.02\f$ with \f$\mathbb{P}_3\f$ Lagrange element for the velocity,
    \f$\mathbb{P}_2\f$ Lagrange for the pressure and \f$\mathbb{P}_1\f$
    Lagrange for the temperature.</center></td>
</tr>
</table>
</center>


\subsection Quantities_Flow Flow rate
Another quantity of interest is the flow rate through the middle of the
tank. We define a segment \f$\Gamma_f\f$ as being the vertical top
semi-segment located at \f$W/2\f$ with height \f$1/2\f$. The flow rate, denoted \f$\mathrm{D}_f\f$, reads
\f{equation*}
  \mathrm{D}_f =  \int_{\Gamma_f} \mathbf{u} \cdot \mathbf{e}_1
\f}
where \f$\mathbf{e}_1=(1,0)\f$. Note that the flow rate can be negative or
positive depending on the direction in which the fluid flows.

As a function of the Grashof, we shall see a increase in the flow
rate. This is true for small Grashof, but starting at \f$1e3\f$ the flow
rate decreases. The fluid is contained in a boundary layer which is
becoming smaller as the Grashof increases.
<center>
<table border=0px>
<tr>
  <td>\image html debit_grashof.png</td>
</tr>
<tr>
  <td><center>Behavior of the flow rate with respect to the Grashof number; <br>\f$h = 0.02\f$,
    \f$\mathbb{P}_3\f$ for the velocity, \f$\mathbb{P}_2\f$ for the pressure and
    \f$\mathbb{P}_1\f$ for the temperature.</center></td>
</tr>
</table>
</center>

section Implementation Implementation
This application in implemented in
\c "feel/doc/manual/heatns/convection.cpp". The implementation solve
the full nonlinear problem using the nonlinear solver framework.

\section Numerical Numerical Schemes
\subsection Numerical_Stokes The Stokes problem
Consider the following problem,
\f{equation*}
  \mbox{Stokes: }\left\{
    \begin{array}{rcc}
      -\mu\Delta\mathbf{u} +
      \nabla p =
      \mathbf{f}\\
      \nabla\cdot\mathbf{u} = 0\\
      \mathbf{u}|_{\partial \Omega} = 0
    \end{array}
  \right.
\f}
where \f$\Omega \subset \mathbb{R}^d\f$. There are no boundary condition
on the pressure. This problem is ill-posed, indeed we only control the
pressure through its gradient \f$\nabla p\f$. Thus if \f$(\mathbf{u},p)\f$ is
a solution, then \f$(\mathbf{u},p+c)\f$ is also a solution with \f$c\f$ any
constant. This comes from the way the problem is posed: the box is
closed and it is not possible to determine the pressure inside. The
remedy is to impose arbitrarily a constraint on the pressure, e.g. its
mean value is zero. In other words, we add this new equation to the
problem
\f{equation}
  \int_\Omega p = 0
\f}
\note This is also true for the incompressible Navier-Stokes equations. We chose Stokes to simplify the exposure.


\subsection Numerical_Reformulation Reformulation
  In order to impose the previous condition, we introduce a new
  unknown, a Lagrange multiplier, \f$\lambda \in \mathbb{R} \f$ and modify
  the incompressibility equation. Our problem reads now, find
  \f$(\mathbf{u},p,\lambda)\f$ such
  that
    \f{equation*}
    \mbox{Stokes 2: }\left\{
      \begin{array}{rcl}
        -\mu\Delta\mathbf{u} +
        \nabla p &=&
        \mathbf{f}\\
        \nabla\cdot\mathbf{u} + \lambda &=& 0\\
        \mathbf{u}|_{\partial \Omega} &=& 0\\
        \int_\Omega p &=& 0
      \end{array}
    \right.
\f}
\note
  The pressure field \f$p\f$ can actually be seen as a Lagrange multiplier
  for the velocity \f$\mathbf{u}\f$ in order to enforce the constraint
  \f$\nabla \cdot \mathbf{u} = 0\f$. \f$\lambda\f$ will play the same role but
  for the pressure to enforce the condition. As \f$h \rightarrow 0\f$, \f$\lambda \rightarrow 0\f$ as well as the divergence of
  \f$\mathbf{u}\f$. Note also that \f$\int_\Omega \nabla \cdot \mathbf{u}
  \approx - \int_\Omega \lambda\f$ from the second equation.


\subsection Numerical_Variational Variational formulation
The variational formulation now reads: find \f$(\mathbf{u}, p,
\lambda) \in \mathbf{H}^1_0(\Omega) \times L^2_0(\Omega) \times
\mathbb{R}\f$ such that for all \f$(\mathbf{v}, q, \eta) \in
\mathbf{H}^1_0(\Omega) \times L^2_0(\Omega) \times \mathbb{R}\f$
\f{equation*}
  \label{notes:eq:20}
  \mbox{Stokes 3: }\left\{
    \begin{array}{rcl}
      \int_\Omega \Big(\nabla \mathbf{u} \colon \nabla \mathbf{v} + \nabla \cdot \mathbf{v} p\Big) &=& \int_\Omega \mathbf{f} \cdot \mathbf{v}\\
      \int_\Omega \Big(\nabla\cdot\mathbf{u} q + \lambda q\Big)   &=& 0\\
      \int_\Omega p \eta &=& 0
    \end{array}
  \right.
\f}

Summing up all three equations we get the following condensed formulation:

\f{equation*}
  \label{notes:eq:19}
  \int_\Omega \nabla \mathbf{u} \colon \nabla \mathbf{v} + \nabla \cdot \mathbf{v} p + \nabla \cdot \mathbf{u} q + \lambda q + \eta p = \int_\Omega \mathbf{f} \cdot \mathbf{v}
\f}
where \f$\mathbf{H}^1_0(\Omega)= \Big\{ \mathbf{v} \in \mathbf{L}^2(\Omega), \nabla \mathbf{v} \in [L^2(\Omega)]^{d\times d},\ \mathbf{v} = 0\ \text{on}\ \partial \Omega \Big\}\f$,
\f$L^2_0(\Omega)= \Big\{ v \in L^2(\Omega),\ \int_\Omega v = 0\Big\}\f$, and
\f$\mathbf{L}^2(\Omega)= \Big\{ \mathbf{v} \in [L^2(\Omega)]^d\Big\}\f$ that is to say each component of a  vector field of \f$\mathbf{L}^2(\Omega)\f$ are in \f$L^2(\Omega)\f$.


\subsection Numercial_Implementation Implementation
\co
//basis
typedef Lagrange<Order, Vectorial> basis_u_type; // velocity
typedef Lagrange<Order-1, Scalar> basis_p_type; // pressure
typedef Lagrange<0, Scalar> basis_l_type; // multipliers
typedef bases<basis_u_type, basis_p_type, basis_l_type> basis_type;
///space: product of the velocity, pressure and multiplier spaces
typedef FunctionSpace<mesh_type, basis_type, value_type> space_type;
// ...
space_ptrtype Xh = space_type::New( mesh );
element_type U( Xh, "u" );
element_type V( Xh, "v" );
element_0_type u = U.element<0>();
element_0_type v = V.element<0>();
element_1_type p = U.element<1>();
element_1_type q = V.element<1>();
element_2_type lambda = U.element<2>();
element_2_type nu = V.element<2>();
// ...
sparse_matrix_ptrtype D( M_backend->newMatrix( Xh, Xh ) );
form2( Xh, Xh, D, _init=true )=
   integrate( elements(mesh), im,
             // $\nabla \mathbf{u} \colon \nabla \mathbf{v}$
              mu*trace(deft*trans(def))
              // $\nabla \cdot \mathbf{v} p + \nabla \cdot \mathbf{u} q$
              - div(v)*idt(p) + divt(u)*id(q)
              // $\lambda q + \eta p$
              +id(q)*idt(lambda) + idt(p)*id(nu) );
// ...
\eco


\subsection Numerical_Fic Fix point iteration for Navier-Stokes
\subsubsection Fix_Steady Steady incompressible Navier-Stokes equations
  Consider the following steady incompressible Navier-Stokes
  equations, find \f$(\mathbf{u},p)\f$ such that
  \f{equation}
    \label{notes:eq:7}
    \begin{split}
      \underbrace{\rho \mathbf{u} \cdot \nabla \mathbf{u}}_{\text{convection}} - \underbrace{\nu \Delta  \mathbf{u}}_{\text{diffusion}} + \nabla p &=  \mathbf{f} \ \text{on}\ \Omega \\
      \nabla \cdot \mathbf{u} &= 0 \\
      \mathbf{u} &= \mathbf{0}\ \text{on}\ \partial \Omega
    \end{split}
  \f}
  where \f$\rho\f$ is the density of the fluid, \f$\nu\f$ is the dynamic
  viscosity of the fluid(la viscosité cinématique \f$\eta = \nu/\rho\f$) and \f$\mathbf{f}\f$ is the external force
  density applied to the fluid, (e.g. \f$\mathbf{f}=-\rho g \mathbf{e}_2\f$ with \f$\mathbf{e}_2=(0,1)^T\f$ ).  This equation system is nonlinear due
  to the \f$\mathbf{u} \cdot \nabla \mathbf{u}\f$ convection term. A
  simple approach to solve \f$(2)\f$ is to use a fix point
  algorithm.

The fixpoint algorithm for NS reads as follows, find
\f$(\mathbf{u}^{(k)},p^{(k)})\f$ such that
    \f{equation*}
      \label{notes:eq:13}
    \begin{split}
      \rho\mathbf{u}^{(k-1)} \cdot \nabla \mathbf{u}^{(k)} - \nu \Delta  \mathbf{u}^{(k)} + \nabla p^{(k)} &= \mathbf{f} \ \text{on}\ \Omega \\
      \nabla \cdot \mathbf{u}^{(k)} &= 0 \\
      \mathbf{u}^{(k)} &= 0\ \text{on}\ \partial \Omega\\
      (\mathbf{u}^{(0)},p^{(0)}) &= (\mathbf{0},0)
    \end{split}
  \f}
  This system  is now linear at each iteration \f$k\f$ and we
  can write the variational formulation accordingly. A stopping
  criterium is for example that
  \f$\|\mathbf{u}^{k}-\mathbf{u}^{(k-1)}\|+\|p^{k}-p^{(k-1)}\| <
  \epsilon\f$ where \f$\epsilon\f$ is a given tolerance (e.g. \f$1e-4\f$) and
  \f$\|\cdot\|\f$ is the \f$L_2\f$ norm.

  Here is the implementation using \Feel:

  \co
    // define some tolerance $\epsilon$
    epsilon = 1e-4;
    // set $(\mathbf{u}^{(0)},p^{(0)})$ to $(\mathbf{0},0)$
    velocity_element_type uk(Xh);
    velocity_element_type uk1(Xh);
    pressure_element_type pk(Ph);
    pressure_element_type pk1(Ph);
    // by default uk1, uk and pk,pk1 are initialized to 0
                                                
    // assemble the linear form associated to $\mathbf{f}$
    // store in vector $F$, it does not change over the iterations
                                               
    // iterations to find $(\mathbf{u}^{(k)},p^{(k)})$
    do
    {
      // save results of previous iterations
      uk1 = uk;
      pk1 = pk;
                                               
      //assemble for bilinear form  associated to
      // $\rho\mathbf{u}^{(k-1)} \cdot \nabla \mathbf{u}^{(k)} - \nu \Delta  \mathbf{u}^{(k)} + \nabla p^{(k)}$
      // store in matrix $A^{(k)}$
                                               
      // solve the system $A^{(k)} X = F$ where $X = (\mathbf{u}^{(k)},p^{(k)})^T$
                                               
      // use uk,uk1 and pk,pk1 to compute the error estimation at each iteration
      error = $\|\mathbf{u}^{k}-\mathbf{u}^{(k-1)}\|+\|p^{k}-p^{(k-1)}\|$
    } while( error > epsilon );
                                               
  \eco

\subsection Nuerical_Coupling A Fix point coupling algorithm
\subsubsection Coupling_Problem Coupling fluid flow and heat transfer: problem
  Recall that we have to solve two coupled problems :
  \f[
  \mbox{Heat(\textbf{u}) }\left\{
  \begin{array}{rcc}
    - \kappa\Delta T + \mathbf{u}\cdot\nabla T &=& 0 \\
    T|_{\Gamma_1} &=& T_0 \\
    \frac{\partial T}{\partial \mathbf{n}}|_{\Gamma_3} &=&1 \\
    \frac{\partial T}{\partial \mathbf{n}}|_{\Gamma_2,\Gamma_4} &=& 0
  \end{array}
  \right.
   \f]

  and
\f[
  \mbox{Stokes(T) : }\left\{
    \begin{array}{rcc}
      -\nu\Delta\mathbf{u} +
      \frac{1}{\rho}\nabla p =
      \mathbf{F}\\
      \nabla\cdot\mathbf{u} = 0\\
      \mathbf{u}|_{\partial \Omega} = 0
    \end{array}
  \right.
\f]

Where \f$\mathbf{F}\f$ can be taken as  \f$
 \left(
  \begin{array}{c}
    0 \\
    \beta(T-T_0)
  \end{array}
\right)
\f$
for some \f$\beta > 0\f$. \f$\beta\f$ is called the \em dilatation \em coefficient.

\subsubsection Coupling_Algorithm Coupling fluid flow and heat transfer: algorithm
Here is a simple algorithm fix point strategy in pseudo-code:
\co
   double tol = 1.e-6;
   int maxIter = 50;
   //Initial guess Un = 0
   do
   {
     // Find Tn solution of Heat(Un)
     // Find Unp1 solution of Stokes(Tn)
     // compute stopTest = norme(Unp1 - Un)
     // Un = Unp1
   }while((stopTest < tol) && (niter <= maxIter));
\eco

\note
  To solve the unsteady problems, one can insert the previous loop in
  the one dedicated to time discretization


\subsection Numerical_Newton A Newton coupling algorithm
\subsubsection Newton_Scheme A fully coupled scheme
  Another possiblity is to use a Newton method which allows us to
  solve the full nonlinear problem coupling velocity, pressure and
  temperature
  \f{equation*}
    \label{notes:eq:21}
    \text{Find}\ X\ \text{such that}\ F(X) = 0
  \f}
  the method is iterative and reads, find \f$X^{(n+1)}\f$ such that
  \f{equation}
    \label{notes:eq:22}
    J_F(X^{(n)})( X^{(n+1)}-X^{(n)}) = - F (X^{(n)})
  \f}
  starting with \f$X^{(0)} = \mathbf{0}\f$ or some other initial value and
  where \f$J_F\f$ is the jacobian matrix of \f$F\f$ evaluated at
  \f$X=((u_i)_i,(p_i)_i,(\theta_i)_i)^T\f$.  For any \f$\phi_k, \psi_l\f$ and
  \f$\rho_m\f$ the \em test functions associated respectively to velocity,
  pressure and temperature, our full system reads, Find \f$X=((u_i)_i,(p_i)_i,(\theta_i)_i)^T\f$ such that
  \f{equation*}
    \label{notes:eq:23}
    \begin{array}{rll}
      F_1((u_i)_i,(p_i)_i,(\theta_i)_i)&=\sum_{i,j} u_i u_j a(\phi_i,\phi_k,\phi_j) - \sum_i p_i b(\phi_k,\psi_i) + \sum_i \theta_i c(\rho_i, \phi_k)+\sum_i u_i d(\phi_i,\phi_k)  &= 0\\
      F_2((u_i)_i,(p_i)_i,(\theta_i)_i)&=\sum_i u_i b(\phi_i,\psi_l) &=0\\
      F_3((u_i)_i,(p_i)_i,(\theta_i)_i)&=\sum_{i,j} u_i\theta_j e(\phi_i,\rho_j,\rho_m) + \sum_i \theta_i f(\rho_i,\rho_m)-g(\rho_m) &=  0
    \end{array}
  \f}
  where \f$F=(F_1,F_2,F_3)^T\f$ and
  \f{equation*}
    \label{notes:eq:26}
    \begin{array}{rl}
    a(\mathbf{u},\mathbf{v},\beta) &= \int_\Omega \mathbf{v}^T ((\nabla \mathbf{u} )\beta)\\
    b(\mathbf{v},p) &= \int_\Omega p (\nabla \cdot \mathbf{v}) - \int_{\partial \Omega} \mathbf{v}\cdot\mathbf{n} p\\
      c(\theta,\mathbf{v})&= \int_\Omega \theta \mathbf{e}_2 \cdot \mathbf{v}\\
      d(\mathbf{u},\mathbf{v}) &= \frac{1}{\sqrt{\mathrm{Gr}}} \Big(\int_\Omega \nabla \mathbf{u} \colon (\nabla \mathbf{v})^T - \int_{\partial \Omega} ((\nabla \mathbf{u}) \mathbf{n})\cdot \mathbf{v}\Big)\\
      e(\mathbf{u},\theta,\chi) &= \int_\Omega (\mathbf{u}\cdot \nabla \theta) \chi \\
      f(\theta,\chi) &=\frac{1}{\sqrt{\mathrm{Gr}}\mathrm{Pr}} \Big( \int_\Omega \nabla \theta \cdot \nabla \chi - \int_{\Gamma_1} (\nabla \theta \cdot \mathbf{n} ) \chi \Big)\\
      g(\chi) &=\frac{1}{\sqrt{\mathrm{Gr}}\mathrm{Pr}} \int_{\Gamma_3} \chi
    \end{array}
  \f}
  \note
    Note that the boundary integrals are kept in order to apply the
    weak Dirichlet boundary condition trick, see next section.


\subsubsection Newton_Jacobian Jacobian matrix
  In order to apply the newton scheme, we need to compute the jacobian
  matrix \f$J_F\f$ by deriving each equation with respect to each
  unknowns, ie \f$u_i, p_i\f$ and \f$\theta_i\f$.
  Consider the first equation
  \li Deriving the first equation with respect to \f$u_i\f$ we get
    \f{equation*}
      \label{notes:eq:301}
      \frac{\partial F_1}{\partial u_i} = \sum_j u_j a(\phi_i,\phi_k,\phi_j) + \sum_i u_i a(\phi_i,\phi_k,\phi_j) + d(\phi_i,\phi_k)
    \f}
  \li Deriving the first equation with respect to \f$p_i\f$ we get
    \f{equation*}
      \label{notes:eq:302}
      \frac{\partial F_1}{\partial p_i} =  -b(\phi_k,\psi_l)
    \f}
  \li Deriving the first equation with respect to \f$\theta_i\f$ we get
    \f{equation*}
      \label{notes:eq:303}
      \frac{\partial F_1}{\partial \theta_i} = c(\rho_i,\rho_k)
    \f}

  Consider the second equation, only the derivative with respect to \f$u_i\f$ is non zero.
  \f{equation*}
    \label{notes:eq:31}
    \frac{\partial F_2}{\partial u_i} = b(\phi_i,\psi_l)
  \f}
  Finally the third component
  \li Deriving with respect to \f$u_i\f$
    \f{equation*}
      \label{notes:eq:33}
      \frac{\partial F_3}{\partial u_i} = \sum_j \theta_j e(\phi_i,\rho_j,\rho_m)
    \f}
  \li Deriving with respect to \f$p_i\f$,
    \f{equation*}
      \label{notes:eq:34}
      \frac{\partial F_3}{\partial p_i} = 0
    \f}
  \li Deriving with respect to \f$theta_i\f$,
    \f{equation*}
      \label{notes:eq:35}
      \frac{\partial F_3}{\partial \theta_i} = \sum_j u_j e(\phi_j,\rho_i,\rho_m) + f(\rho_i,\rho_m)
    \f}
  \f{equation*}
    \label{notes:eq:36}
    J_F =
    \begin{pmatrix}
      \frac{\partial F_1}{\partial u_i} & \frac{\partial F_1}{\partial p_i} & \frac{\partial F_1}{\partial \theta_i} \\
      {\frac{\partial F_2}{\partial u_i}} & {\frac{\partial F_2}{\partial p_i}}(=0) & {\frac{\partial F_2}{\partial \theta_i}}(=0) \\
      \frac{\partial F_3}{\partial u_i} & {\frac{\partial F_3}{\partial p_i}}(=0) & \frac{\partial F_3}{\partial \theta_i}
    \end{pmatrix}
  \f}
  In order to implement \f$J_F\f$ and solve \f$(3)\f$, \f$J_F\f$ can be
  expressed as the matrix associated with the discretisation of
  \f{equation*}
    \label{notes:eq:37}
    \begin{array}{rl}
      a(\mathbf{u},\mathbf{v},\beta_1) + a(\beta_1, \mathbf{v}, \mathbf{u})+d(\mathbf{u},\mathbf{v})-b(\mathbf{v},p)+c(\theta,\mathbf{v}) &= 0\\
      b(\mathbf{u},q)&=0\\
      e(\beta_1,\theta,\chi)+f(\theta,\chi)+e(\mathbf{u},\beta_2,\chi)&=0\\
    \end{array}
  \f}
  where \f$\beta_1 = u^{(n)}\f$, \f$\beta_2=\theta^{(n)}\f$ are known from the
  previous Newton iteration, indeed \f$J_F\f$ is actually evaluated in \f$X^{(n)}\f$.

\subsubsection Newton_Implementation Implementation
  Now we use the \feel non linear framework in order to implement our
  Newton scheme.
  We need to define two new functions in our application
  \li \c updateJacobian(X,J) which takes as input \c X\f$=X^{(n)}\f$ and returns the matrix \c J=\f$J_F(X^{(n)})\f$
  \li \c updateResidual(X,R) which takes as input \c X\f$=X^{(n)}\f$ and returns the vector \c R=\f$F(X^{(n)})\f$

  \note
    Only the PETSC backend supports the nonlinear solver framework.
    Use  in the command line like in the first section
    \co
      --backend=petsc
    \eco

  Here is a snippet of code that implements the nonlinear framework.
  \co
    class MyApp
    {
      public:
      void run();
      void updateResidual( const vector_ptrtype& X, vector_ptrtype& R );
      void updateJacobian( const vector_ptrtype& X, sparse_matrix_ptrtype& J);
      void solve( sparse_matrix_ptrtype& D, element_type& u, vector_ptrtype& F );
      private:

      backend_ptrtype M_backend;
      sparse_matrix_ptrtype M_jac;
      vector_ptrtype M_residual;
    };
                                        
    void
    MyApp::run()
    {
      // ...
                                        
      // plug the updateResidual and updateJacobian functions
      // in the nonlinear framework
      M_backend->nlSolver()->residual = boost::bind( &self_type::updateResidual,
                                                     boost::ref( *this ), _1, _2 );
      M_backend->nlSolver()->jacobian = boost::bind( &self_type::updateJacobian,
                                                     boost::ref( *this ), _1, _2 );
                                        
      vector_ptrtype U( M_backend->newVector( u.functionSpace() ) );
      *U = u;
      vector_ptrtype R( M_backend->newVector( u.functionSpace() ) );
      this->updateResidual( U, R );
      sparse_matrix_ptrtype J;
      this->updateJacobian( U, J );
      solve( J, u, R );
                                        
      *U = u;
      this->updateResidual( U, R );
      // R(u) should be small
      std::cout << "R( u ) = " << M_backend->dot( U, R ) << "\n";
                                        

    }
    void
    MyApp::solve( sparse_matrix_ptrtype& D, element_type& u, vector_ptrtype& F )
    {
      vector_ptrtype U( M_backend->newVector( u.functionSpace() ) );
      *U = u;
      M_backend->nlSolve( D, U, F, 1e-10, 10 );
      u = *U;
    }
    void
    MyApp::updateResidual( const vector_ptrtype& X, vector_ptrtype& R )
    {
      // compute R(X)

      R=M_residual;
    }
    void
    MyApp::updateJacobian( const vector_ptrtype& X, vector_ptrtype& R )
    {
      // compute J(X)

      J=M_jac;
    }
  \eco
  see \c bratu.cpp or \c nonlinearpow.cpp for example.











*/
}
