/* -*- mode: c++; coding: utf-8; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4; show-trailing-whitespace: t  -*-

 This file is part of the Feel++ library

 Author(s): Guillaume Doll√© <gdolle@unistra.fr>
 Date: 26 Mar 2015

 Copyright (C) 2015 Feel++ Consortium

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

#if 1
#define BOOST_TEST_MODULE test_worldcomm
#include <feel/feelcore/testsuite.hpp>
#else
#define USE_BOOST_TEST 0
#endif

#include <feel/feelfilters/loadmesh.hpp>
#include <feel/feelalg/backend.hpp>
#include <feel/feeldiscr/pch.hpp>
#include <feel/feelvf/vf.hpp>
#include <feel/feelfilters/exporter.hpp>

inline
Feel::po::options_description
makeOptions()
{
    Feel::po::options_description wcopts( "Test Environment options" );
    wcopts.add_options()
        ( "Npcomm", Feel::po::value<double>()->default_value( 2 ), "Number of communicators (>=2)" )
    ;
    return wcopts.add( Feel::feel_options() );
}

inline
Feel::AboutData
makeAbout()
{
    Feel::AboutData about( "test_worldcomm" ,
                           "test_worldcomm" ,
                           "0.1",
                           "MPI communicators test",
                           Feel::AboutData::License_LGPL,
                           "Copyright (c) 2015 Feel++ Consortium" );

    about.addAuthor( "Guillaume Dolle", "developer", "gdolle@unistra.fr", "" );
    return about;
}

#if USE_BOOST_TEST
FEELPP_ENVIRONMENT_WITH_OPTIONS( makeAbout(), makeOptions() )
BOOST_AUTO_TEST_SUITE( worldcomm )

// Create Npcomm communicators and solve in parallel two laplacians with
// two different boundary strong conditions.
BOOST_AUTO_TEST_CASE( test_0 )
{
    using namespace Feel;

    auto& world = Environment::worldComm();
    // Number of communicators to create (Np=k*Ncomm).
    const int Npcomm = 2;
    const int Np = world.size();

    BOOST_CHECK( Npcomm >= 2 );

    if( Np>=Npcomm && !(Np%Npcomm) )
    {
        int color = world.rank() % Npcomm;

        // create map which color the world
        std::vector<int> mapColorWorld;
        for( int rank : irange( 0, world.size() ) )
            mapColorWorld.push_back( rank % Npcomm );
        std::cout << "1" << std::endl;
        // build a global world comm colored
        // this worldcomm can have a global mpi comm (on world) : worldColored.globalComm()
        // this worldcomm can have a local mpi comm (mpi group with color) : worldColored.localComm()
        // all proc are active
        worldcomm_ptr_t worldColored = std::make_shared<worldcomm_t>( mapColorWorld );
        worldColored->showMe();
        std::cout << "2" << std::endl;
        // a local worldcomm (mpi group on color)
        // w.globalComm() and w.localComm() are same communicator
        // only proc on color are active
        worldcomm_ptr_t w = worldColored->subWorldComm( color );
        w->showMe();
        std::cout << "3" << std::endl;
        using mesh_type = Mesh< Simplex<2> >;
        std::shared_ptr<mesh_type> mesh;
        
        // generate the mesh only by one group (color 0)
        if ( color == 0 )
        {
            CHECK( w->isActive() ) << "this worldcomm w must be active";
            mesh = loadMesh( _mesh = new mesh_type(w),
                             _filename = "test_twodomains.geo"
                             );
        }
        worldColored->globalComm().barrier();
        
        if ( w->isActive() )
        {
            // reload the mesh generated by the mpi group of color 0
            if ( color != 0 )
                mesh = loadMesh( _mesh = new mesh_type(w),
                                 _filename = "test_twodomains.geo"
                                 );
            BOOST_WARN( mesh->numberOfPartitions()!= w->localSize() );
        }
        else
            mesh.reset( new mesh_type(w) ); // an empty mesh
        std::cout << "3.0" << std::endl;
        return;

        // Create a feel++ worldcomm using local communicators.
        auto bend = backend( _worldcomm=w );
        std::cout << "3.1" << std::endl;
        
        auto Xh = Pch<1>( mesh );
        std::cout << "3.2" << std::endl;
        auto u = Xh->element();
        auto v = Xh->element();
        std::cout << "3.3" << std::endl;
        // Bilinear form2 create the matrix using the backend worldcomm.
        auto a = form2( _test=Xh, _trial=Xh, _backend=bend );

        a+= integrate( _range=markedelements(mesh,"omega"),
                       _expr=gradt(u)*trans(grad(v) ) );

        // Linear form1 create the vector using the backend worldcomm.
        auto l = form1( _test=Xh, _backend=bend );
        l+= integrate( _range=markedelements(mesh,"omega"),
                       _expr=id(v) );
        std::cout << "4" << std::endl;
        // operators on(..) and solve(..) must check if w.isActive()
        // TODO hid this in feel
        if ( w->isActive() )
        {
            a += on( _range=markedfaces( mesh, "wall"), _rhs=l, _element=u, _expr=cst(color) );
            // solveb use the backend worldcomm
            a.solveb( _rhs=l, _solution=u, _backend=bend );
        }
        std::cout << "5" << std::endl;
        BOOST_MESSAGE( "nMeshParts: " << mesh->numberOfPartitions()
                       << " | color: " << color
                       << " | god rank: " << w->godRank()
                       << " | global rank: " << w->globalRank()
                       << " | local rank: " << w->localRank()
                       //<< " u size: " << u.size()
                       //<< " u[0]: " << u[0] << std::endl;
                       << "\n"
                     );


        // important : name of exporter and  field (in add ) must be differancited with the color by example
        auto e = exporter( _mesh=mesh, _name=( boost::format("laplacian_%1%") % color ).str() );
        e->add((boost::format("u_%1%")%color).str(),u);
        e->save();
        std::cout << "6" << std::endl;
        auto strcase = fs::path(Environment::exportsRepository()) / fs::path( soption( _name="exporter.format" ) ) / fs::path( e->getPrefix() ) / fs::path( (boost::format("laplacian_%1%.case") % color).str() );
        BOOST_MESSAGE( "Find file on color: "<< color << " strcase: " << strcase << "\n" );
        auto caseFileExist = !(Environment::findFile( strcase.string() )).empty();

        // Check if each communicator has created its ensight .case file.
        if( w->localRank() == 0 )
            BOOST_CHECK( caseFileExist );
        worldColored->globalComm().barrier();

    }
}
BOOST_AUTO_TEST_CASE( test_split )
{
    using namespace Feel;
    if ( Environment::numberOfProcessors() > 1 && Environment::numberOfProcessors()%2 == 0 )
    {
        BOOST_TEST_MESSAGE(fmt::format("check split"));
        auto [color,w,wglob]=Environment::worldCommPtr()->split(2);
        BOOST_CHECK( wglob->globalSize() == Environment::numberOfProcessors());
        BOOST_CHECK( wglob->localSize() == Environment::numberOfProcessors()/2);
        BOOST_CHECK( w->localSize() == Environment::numberOfProcessors()/2);
        BOOST_CHECK( w->globalSize() == Environment::numberOfProcessors()/2);
    }
}
BOOST_AUTO_TEST_SUITE_END()
#endif
